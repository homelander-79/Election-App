{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AutomationCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"
    },
    "contracts/Election.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol\";\nimport \"./structs.sol\";\n\nerror user__not__exist();\nerror Not_Allowed();\nerror out_of_time();\nerror already_voted();\nerror already_exist();\nerror Not_Found();\nerror candidate_Not_Exist();\nerror Election_UpkeepNotNeeded();\n\n/**\n *       @title this is a sample Election App\n *       @author moah\n *       @dev this implements Chainlink Keepers\n */\n\ncontract Election is AutomationCompatibleInterface {\n    /*tyoe declaration */\n\n    enum ElectionState {\n        CLOSE,\n        OPEN\n    }\n\n    /*election variable */\n\n    ElectionState private s_ellectionState;\n    uint256 private s_timeStamp;\n    uint216 private s_interval;\n    uint256 private s_lastTimeStamp;\n    address private immutable i_owner;\n    address[] private s_admins;\n    uint256 private s_lastcandidateId;\n    uint256 private s_electionId;\n    string[] private s_numOfcandidates;\n    mapping(address => Structs.User) private users;\n    mapping(string => Structs.Candidate) private candidate;\n    mapping(uint256 => Structs.Elction) private election;\n\n    /* modefiers */\n\n    modifier onlyOwner() {\n        if (msg.sender != i_owner) {\n            revert Not_Allowed();\n        }\n        _;\n    }\n\n    modifier onlyAdmins() {\n        for (uint256 i = 0; i < s_admins.length; i++) {\n            if (msg.sender == s_admins[i]) {\n                _;\n            }\n        }\n    }\n\n    /*constructor */\n\n    constructor() {\n        s_ellectionState = ElectionState.CLOSE;\n        i_owner = msg.sender;\n        s_admins.push(i_owner);\n        s_electionId = 0;\n        initializecandidates();\n    }\n\n    /*functions */\n\n    function addAdmin(address addr) public onlyOwner {\n        for (uint256 i = 0; i < s_admins.length; i++) {\n            if (s_admins[i] == addr) revert already_exist();\n        }\n        s_admins.push(addr);\n    }\n\n    function addcandidate(\n        string memory candidateName,\n        string memory description,\n        string memory party\n    ) public onlyAdmins {\n        candidate[candidateName].candidateName = candidateName;\n        candidate[candidateName].description = description;\n        candidate[candidateName].party = party;\n        candidate[candidateName].nominationNumber = 0;\n        candidate[candidateName].numberOfWins = 0;\n        s_numOfcandidates.push(candidateName);\n    }\n\n    function addElection(\n        uint256 interval,\n        string[4] memory candidates,\n        string memory title,\n        string memory description\n    ) public onlyAdmins {\n        if ((block.timestamp - s_lastTimeStamp) > s_interval) {\n            s_electionId += 1;\n            election[s_electionId].electionId = s_electionId;\n            election[s_electionId].title = title;\n            election[s_electionId].interval = interval;\n            election[s_electionId].description = description;\n            election[s_electionId].isClose = false;\n            election[s_electionId].winner = \"-1\";\n            for (uint256 i = 0; i < candidates.length; i++) {\n                if (keccak256(abi.encode(candidates[i])) == keccak256(abi.encode(\"\"))) {\n                    break;\n                }\n                if (\n                    keccak256(abi.encode(candidates[i])) !=\n                    keccak256(abi.encode(candidate[candidates[i]].candidateName))\n                ) {\n                    revert candidate_Not_Exist();\n                }\n                candidate[candidates[i]].nominationNumber += 1;\n                election[s_electionId].candidateNames.push(candidates[i]);\n            }\n\n            for (uint256 i = 0; i < election[s_electionId].candidateNames.length; i++) {\n                election[s_electionId]\n                    .votes[election[s_electionId].candidateNames[i]]\n                    .numOfVotes = 0;\n            }\n\n            s_ellectionState = ElectionState.OPEN;\n\n            s_lastTimeStamp = block.timestamp;\n        }\n    }\n\n    function vote(address voter, string memory candidateName) public {\n        uint256 electionId = s_electionId;\n        if (\n            (s_ellectionState == ElectionState.OPEN) &&\n            ((block.timestamp - s_lastTimeStamp) < election[s_electionId].interval)\n        ) {\n            if (!users[voter].isValid) {\n                users[voter].id = voter;\n                users[voter].isValid = true;\n            }\n\n            if (!users[voter].votes[electionId].isVoted) {\n                users[voter].votes[electionId].electionId = electionId;\n                users[voter].votes[electionId].candidateName = candidateName;\n                election[electionId].votes[candidateName].numOfVotes += 1;\n                users[voter].votes[electionId].isVoted = true;\n            } else revert already_voted();\n        } else revert out_of_time();\n    }\n\n    function checkUpkeep(\n        bytes memory /* checkData */\n    ) public view override returns (bool upkeepNeeded, bytes memory /* performData */) {\n        bool timeSet = (s_lastTimeStamp != 0);\n        bool isOpen = (ElectionState.OPEN == s_ellectionState);\n        bool timePassed = ((block.timestamp - s_timeStamp) > s_interval);\n        upkeepNeeded = (isOpen && timePassed && timeSet);\n        return (upkeepNeeded, \"0x0\");\n    }\n\n    function performUpkeep(bytes calldata /* performData */) external override {\n        (bool upkeepNeeded, ) = checkUpkeep(\"\");\n        if (!upkeepNeeded) {\n            revert Election_UpkeepNotNeeded();\n        }\n        setResult();\n    }\n\n    function setResult() internal {\n        if ((block.timestamp - s_lastTimeStamp) > election[s_electionId].interval) {\n            s_ellectionState = ElectionState.CLOSE;\n            s_lastTimeStamp = 0;\n            election[s_electionId].isClose = true;\n\n            uint256 numOfVotes = 0;\n            string memory winner = \"0\";\n\n            for (uint256 i = 0; i < election[s_electionId].candidateNames.length; i++) {\n                if (\n                    election[s_electionId]\n                        .votes[election[s_electionId].candidateNames[i]]\n                        .numOfVotes > numOfVotes\n                ) {\n                    winner = election[s_electionId].candidateNames[i];\n\n                    numOfVotes = election[s_electionId]\n                        .votes[election[s_electionId].candidateNames[i]]\n                        .numOfVotes;\n                } else if (\n                    (election[s_electionId]\n                        .votes[election[s_electionId].candidateNames[i]]\n                        .numOfVotes == numOfVotes) &&\n                    ((keccak256(abi.encode(winner)) != keccak256(abi.encode(\"0\"))) ||\n                        (keccak256(abi.encode(winner)) != keccak256(abi.encode(\"-1\"))))\n                ) {\n                    winner = \"0\";\n                }\n            }\n\n            election[s_electionId].winner = winner;\n            if (\n                (keccak256(abi.encode(winner)) != keccak256(abi.encode(\"0\"))) ||\n                (keccak256(abi.encode(winner)) != keccak256(abi.encode(\"-1\")))\n            ) {\n                candidate[winner].numberOfWins += 1;\n            }\n        }\n    }\n\n    /** Getter Functions */\n\n    function isOwner(address addr) public view returns (uint256) {\n        if (addr == i_owner) {\n            return 1;\n        } else return 0;\n    }\n\n    function isAdmins(address addr) public view returns (uint256) {\n        for (uint256 i = 0; i < s_admins.length; i++) {\n            if (s_admins[i] == addr) return 1;\n        }\n        return 0;\n    }\n\n    function isUserExist(address addr) public view returns (bool) {\n        return users[addr].isValid;\n    }\n\n    function getElectionsCount() public view returns (uint256) {\n        return s_electionId;\n    }\n\n    function getcandidate(string memory name) public view returns (Structs.Candidate memory) {\n        if (keccak256(abi.encode(candidate[name].candidateName)) == keccak256(abi.encode(name))) {\n            return candidate[name];\n        } else revert candidate_Not_Exist();\n    }\n\n    function getReminingTime() public view returns (uint256) {\n        if ((block.timestamp - s_lastTimeStamp) > election[s_electionId].interval) return 0;\n        else return election[s_electionId].interval - (block.timestamp - s_lastTimeStamp);\n    }\n\n    function getUserHistory(address addr) public view returns (Structs.UserVotes[] memory) {\n        if (users[addr].isValid) {\n            uint256 voteCounter = 0;\n            for (uint256 i = 1; i <= s_electionId; i++) {\n                if (users[addr].votes[i].isVoted) {\n                    voteCounter += 1;\n                }\n            }\n\n            Structs.UserVotes[] memory history = new Structs.UserVotes[](voteCounter);\n\n            uint256 historycounter = 0;\n\n            for (uint256 i = 1; i <= s_electionId; i++) {\n                if (users[addr].votes[i].isVoted) {\n                    history[historycounter] = users[addr].votes[i];\n                    historycounter += 1;\n                }\n            }\n            return history;\n        } else revert user__not__exist();\n    }\n\n    function getCurrrentElection()\n        public\n        view\n        returns (\n            string memory,\n            string memory,\n            string[] memory,\n            Structs.candidateVote[] memory,\n            string memory\n        )\n    {\n        uint256 candidateCount = 0;\n        uint256 lastElection = s_electionId;\n\n        for (uint256 i = 1; i <= election[lastElection].candidateNames.length; i++) {\n            candidateCount += 1;\n        }\n        Structs.candidateVote[] memory candidateVotes = new Structs.candidateVote[](candidateCount);\n\n        for (uint256 i = 0; i < candidateCount; i++) {\n            candidateVotes[i] = election[lastElection].votes[\n                election[lastElection].candidateNames[i]\n            ];\n        }\n\n        return (\n            election[lastElection].title,\n            election[lastElection].description,\n            election[lastElection].candidateNames,\n            candidateVotes,\n            election[lastElection].winner\n        );\n    }\n\n    function getElectionsTable() public view returns (Structs.Table[] memory) {\n        Structs.Table[] memory history = new Structs.Table[](s_electionId);\n        for (uint256 i = 1; i <= s_electionId; i++) {\n            history[i - 1].electionId = election[i].electionId;\n            history[i - 1].description = election[i].description;\n            history[i - 1].winner = election[i].winner;\n        }\n        return history;\n    }\n\n    function getElectionById(\n        uint256 electionId\n    )\n        public\n        view\n        returns (\n            bool,\n            string memory,\n            string memory,\n            string[] memory,\n            Structs.candidateVote[] memory,\n            string memory\n        )\n    {\n        if (election[electionId].electionId == electionId) {\n            uint256 candidateCount = 0;\n            for (uint256 i = 0; i < election[electionId].candidateNames.length; i++) {\n                candidateCount += 1;\n            }\n            Structs.candidateVote[] memory candidateVotes = new Structs.candidateVote[](\n                candidateCount\n            );\n\n            for (uint256 i = 0; i < candidateCount; i++) {\n                candidateVotes[i] = election[electionId].votes[\n                    election[electionId].candidateNames[i]\n                ];\n            }\n\n            return (\n                election[electionId].isClose,\n                election[electionId].title,\n                election[electionId].description,\n                election[electionId].candidateNames,\n                candidateVotes,\n                election[electionId].winner\n            );\n        } else revert Not_Found();\n    }\n\n    // primery data\n\n    function initializecandidates() internal {\n        addcandidate(\n            \"Satya\",\n            \"Satya Narayana Nadella is an Indian-American business executive. He is the executive chairman and CEO of Microsoft, succeeding Steve Ballmer in 2014 as CEO and John W. Thompson in 2021 as chairman.\",\n            \"microsoft\"\n        );\n        addcandidate(\n            \"Jeff\",\n            \"Jeffrey Preston Bezos is an American entrepreneur, media proprietor, investor, and commercial astronaut. He is the founder, executive chairman, and former president and CEO of Amazon\",\n            \"Amazon\"\n        );\n        addcandidate(\n            \"Elon\",\n            \"Elon Reeve Musk FRS is a business magnate and investor. He is the founder, CEO and chief engineer of SpaceX; angel investor, CEO and product architect of Tesla, Inc.; owner and CEO of Twitter, Inc.; founder of The Boring Company; co-founder of Neuralink and OpenAI; and president of the philanthropic Musk Foundation\",\n            \"SpaceX\"\n        );\n        addcandidate(\n            \"Mark\",\n            \"Mark Elliot Zuckerberg is an American business magnate, internet entrepreneur, and philanthropist. He is known for co-founding the social media website Facebook and its parent company Meta Platforms, of which he is the chairman, chief executive officer, and controlling shareholder\",\n            \"meta\"\n        );\n        addcandidate(\n            \"Pavel\",\n            \"Pavel Valeryevich Durov is a Russian-born French-Emirati entrepreneur who is known for being the founder of the social networking site VK and Telegram Messenger. He is the younger brother of Nikolai Durov.\",\n            \"telegram\"\n        );\n    }\n}\n"
    },
    "contracts/structs.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n *       @author moah\n */\n\nlibrary Structs {\n    struct User {\n        address id;\n        bool isValid;\n        mapping(uint256 => UserVotes) votes;\n    }\n\n    struct UserVotes {\n        uint256 electionId;\n        string candidateName;\n        bool isVoted;\n    }\n\n    struct Candidate {\n        string candidateName;\n        string description;\n        string party;\n        uint256 nominationNumber;\n        uint256 numberOfWins;\n    }\n\n    struct Elction {\n        uint256 electionId;\n        string title;\n        uint256 interval;\n        string description;\n        bool isClose;\n        string[] candidateNames;\n        mapping(string => candidateVote) votes;\n        string winner;\n    }\n\n    struct candidateVote {\n        string candidateNames;\n        uint256 numOfVotes;\n    }\n\n    struct Table {\n        uint256 electionId;\n        string description;\n        string winner;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}